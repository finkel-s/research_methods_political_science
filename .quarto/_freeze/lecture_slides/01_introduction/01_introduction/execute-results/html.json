{
  "hash": "a25f15fd70b354627e253bb8526fe852",
  "result": {
    "markdown": "---\ntitle: \"<span style = 'font-size: 100%;'> MGMT 47400: Predictive Analytics </span>\"\nsubtitle: \"<span style = 'font-size: 150%;'> Syllabus, Logistics,  and  Introduction</span>\"\nauthor: \"Professor: Davi Moreira\"\n#date: \"2024-08-01\"\ndate-format: \"MMMM DD, YYYY\"\nformat:\n  revealjs: \n    transition: slide\n    background-transition: fade\n    width: 1600\n    height: 900\n    center: true\n    slide-number: true\n    incremental: true\n    chalkboard: \n      buttons: false\n    preview-links: auto\n    #logo: images/quarto.png\n    footer: \"Predictive Analytics\"\n    theme: [simple,custom.scss]\nhtml-math-method:\n  method: mathjax\n  url: \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"\n  \n---\n\n\n# Welcome! {background-color=\"#cfb991\"}\n\n## Overview\n\n:::::: nonincremental\n::::: columns\n::: {.column width=\"50%\" style=\"text-align: center; justify-content: center; align-items: center;\"}\n\n-   Introductions\n-   Course Overview and Logistics\n-   Motivation\n-   Course Objectives \n\n:::\n\n::: {.column width=\"50%\" style=\"text-align: center; justify-content: center; align-items: center;\"}\n\n- Supervised Learning\n- Unsupervised Learning\n- Statistical Learning Overview\n    \n    - What is Statistical Learning?\n    - Parametric and Structured Models\n    - Assessing Model Accuracy \n    - Classification Problems \n\n:::\n:::::\n::::::\n\n<br>\n\n*This lecture content is inspired by and replicates the material from [An Introduction to Statistical Learning](https://www.statlearning.com/).*\n\n# Introductions  {background-color=\"#cfb991\"}\n\n## Instructor\n\n::::: columns\n::: {.column width=\"40%\" style=\"text-align: center; justify-content: center; align-items: center;\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/davi_moreira_photo.JPG){fig-align='center' width=60%}\n:::\n:::\n\n\n[dmoreira\\@purdue.edu](dmoreira@purdue.edu)\n\n<https://davi-moreira.github.io/>\n:::\n\n::: {.column width=\"60%\" style=\"text-align: center; justify-content: center; align-items: center;\"}\n-   Clinical Assistant Professor in the Management Department at Purdue University;\n\n<br>\n\n-   My academic work addresses Political Communication, Data Science, Text as Data, Artificial Intelligence, and Comparative Politics.\n\n<br>\n\n-   [M&E Specialist consultant - World Bank (Brazil, Mozambique, Angola, and DRC)](https://blogs.worldbank.org/opendata/improving-how-we-measure-progress-community-biodiversity-conservation-projects-mozambique)\n:::\n:::::\n\n## Instructor's Passions\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/palmeiras_logo.png){fig-align='center' width=17%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/palmeiras_stadium.jpg){fig-align='center' width=40%}\n:::\n:::\n\n\n<center>\n\n::: {style=\"font-size: 80%;\"}\n[The Most Exciting Game in History - Video](https://www.youtube.com/watch?v=FCebgeX_3hI&t=89s)\n:::\n\n</center>\n\n<br> <br>\n\n## Instructor's Passions\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/carnaval_olinda.jpg){fig-align='center' width=25%}\n:::\n:::\n\n\n<center>[NYT - How John Travolta Became the Star of Carnival](https://www.nytimes.com/2024/02/13/world/americas/brazil-carnival-john-travolta.html)[-Video.](https://www.nytimes.com/video/world/americas/100000009311331/the-star-of-this-carnival-is-a-giant-john-travolta-puppet.html?auth=login-google1tap&login=google1tap)</center>\n\n<br>\n\n## Students\n\n<br>\n\n-   It is your turn! - 5 minutes\n\n<br>\n\n-   Present yourself to your left/right colleague and tell her/him what are the current two main passions in your life.\n\n# Course Overview and Logistics {background-color=\"#cfb991\"}\n\n## Course Overview and Logistics\n\n-   **Materials**:\n\n    -   Brightspace\n\n    -   [Course Webpage](https://davi-moreira.github.io/2025S_predictive_analytics_MGMT474/){target=\"_blank\"}\n\n-   [**Syllabus**](https://davi-moreira.github.io/2025S_predictive_analytics_MGMT474/){target=\"_blank\"}\n\n      - **Class Times & Location:**  check the course syllabus.\n      - **Office Hours:** check the course syllabus for group and individual appointments. \n\n-   [**Schedule**](https://davi-moreira.github.io/2025S_predictive_analytics_MGMT474/){target=\"_blank\"}\n\n# Motivation {background-color=\"#cfb991\"}\n\n<!---\n\n## Statistical Learning Problems\n\n- **Identify the risk factors for prostate cancer.**\n\n- Classify a recorded phoneme based on a log-periodogram.\n\n- Predict whether someone will have a heart attack on the basis of demographic, diet, and clinical measurements.\n\n- Customize an email spam detection system.\n\n- Identify the numbers in a handwritten zip code.\n\n- Classify a tissue sample into one of several cancer classes, based on a gene expression profile.\n\n- Establish the relationship between salary and demographic variables in population survey data.\n\n- Classify the pixels in a LANDSAT image, by usage.\n\n--->\n\n## Spam Detection\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n- Data from 4601 emails sent to an individual (named George, at HP Labs, before 2000). Each is labeled as *spam* or *email*.\n- Goal: build a customized spam filter.\n- Input features: relative frequencies of 57 of the most commonly occurring words and punctuation marks in these email messages.\n\n| Word   | Spam | Email |\n|--------|------|-------|\n| george | 0.00 | 1.27  |\n| you    | 2.26 | 1.27  |\n| hp     | 0.02 | 0.90  |\n| free   | 0.52 | 0.07  |\n| !      | 0.51 | 0.11  |\n| edu    | 0.01 | 0.29  |\n| remove | 0.28 | 0.01  |\n\n*Average percentage of words or characters in an email message equal to the indicated word or character. We have chosen the words and characters showing the largest difference between spam and email.*\n\n:::\n:::\n\n## Zip Code\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\nIdentify the numbers in a handwritten zip code.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/zip_code.png){fig-align='center' width=45%}\n:::\n:::\n\n\n:::\n:::\n\n<br>\n\n## Netflix Prize\n\n<br>\n\n<center>\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/netflix_prize.png){fig-align='center' width=60%}\n:::\n:::\n\n\n[Video: Winning the Netflix Prize](https://www.youtube.com/watch?v=ImpV70uLxyw){target=\"_blank\"}\n\n[Netflix Prize - Wiki](https://en.wikipedia.org/wiki/Netflix_Prize){target=\"_blank\"}\n\n<br>\n\n</center>\n\n\n# Supervised Learning {background-color=\"#cfb991\"}\n\n## Starting point\n\n<br>\n\n::: nonincremental\n::: {style=\"font-size: 90%;\"}\n\n\n- Outcome measurement $Y$ (also called dependent variable, response, target).\n\n- Vector of $p$ predictor measurements $X$ (also called inputs, regressors, covariates, features, independent variables).\n\n- In the regression problem, $Y$ is quantitative (e.g., price, blood pressure).\n\n- In the classification problem, $Y$ takes values in a finite, unordered set (e.g., survived/died, digit 0–9, cancer class of tissue sample).\n\n- We have training data $(x_1, y_1), \\ldots, (x_N, y_N)$. These are observations (examples, instances) of these measurements.\n\n:::\n:::\n\n## Objectives\n\nOn the basis of the training data, we would like to:\n\n- Accurately predict unseen *test* cases.\n\n- Understand which inputs affect the outcome, and how.\n\n- Assess the quality of our predictions and inferences.\n\n## Philosophy\n\n<br>\n\n::: nonincremental\n\n- It is important to understand the ideas behind the various techniques, in order to know how and when to use them.\n\n- We wil understand the simpler methods first to grasp the more sophisticated ones later.\n\n- It is important to accurately assess the performance of a method, to know how well or how badly it is working.\n\n:::\n\n# Unsupervised Learning  {background-color=\"#cfb991\"}\n\n## Unsupervised Learning\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n- No outcome variable, just a set of predictors (features) measured on a set of samples.\n\n- Objective is more fuzzy:\n\n    - Find groups of samples that behave similarly.\n    \n    - Find features that behave similarly.\n    \n    - Find linear combinations of features with the most variation.\n\n- Difficult to know how well we are doing.\n\n- Different from supervised learning, but can be useful as a pre-processing step for supervised learning.\n\n:::\n:::\n\n<!---\n## Statistical Learning versus Machine Learning\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n- Machine learning arose as a subfield of Artificial Intelligence.\n\n- Statistical learning arose as a subfield of Statistics.\n\n- **There is much overlap—both fields focus on supervised and unsupervised problems:**\n    \n    - Machine learning has a greater emphasis on *large scale applications* and *prediction accuracy*.\n    \n    - Statistical learning emphasizes *models* and their *interpretability*, and *precision* and *uncertainty*.\n\n- The distinction has become more blurred, with significant cross-fertilization.\n\n- Machine learning has the upper hand in *Marketing*!\n\n:::\n:::\n--->\n\n# Statistical Learning Overview {background-color=\"#cfb991\"}\n# What is Statistical Learning? {background-color=\"#cfb991\"}\n## What is Statistical Learning?\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\nShown are **Sales** vs **TV**, **Radio**, and **Newspaper**, with a blue linear-regression line fit separately to each.\n\nCan we predict **Sales** using these three?  \n\n:::{.fragment}\n\nPerhaps we can do better using a model:\n\n$$\n\\text{Sales} \\approx f(\\text{TV}, \\text{Radio}, \\text{Newspaper})\n$$\n\n:::\n:::\n:::\n\n<br>\n\n## Notation\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n\n:::{.nonincremental}\n\n- **Sales** is a *response* or *target* that we wish to predict. We generically refer to the response as $Y$.\n\n- **TV** is a *feature*, or *input*, or *predictor*; we name it $X_1$.  \n  Likewise, name **Radio** as $X_2$, and so on.\n\n- The input vector collectively is referred to as:\n\n$$\nX = \\begin{pmatrix}\nX_1 \\\\\nX_2 \\\\\nX_3\n\\end{pmatrix}\n$$\n\nWe write our model as:\n\n$$\nY = f(X) + \\epsilon\n$$\n\nwhere $\\epsilon$ captures measurement errors and other discrepancies.\n\n:::\n\n:::\n:::\n\n\n## What is $f(X)$ Good For?\n\n- With a good $f$, we can make predictions of $Y$ at new points $X = x$.\n\n- Understand which components of $X = (X_1, X_2, \\ldots, X_p)$ are important in explaining $Y$, and which are irrelevant.\n\n    - Example: *Seniority* and *Years of Education* have a big impact on *Income*, but *Marital Status* typically does not.\n    \n- Depending on the complexity of $f$, understand how each component $X_j$ affects $Y$.\n\n\n## Is There an Ideal $f(X)$?\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\nIn particular, what is a good value for $f(X)$ at a selected value of $X$, say $X = 4$?  \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_2.png){fig-align='center' width=60%}\n:::\n:::\n\n\n:::{.fragment}\n\nThere can be many $Y$ values at $X=4$. A good value is:\n\n$$\nf(4) = E(Y|X=4)\n$$\n\nwhere $E(Y|X=4)$ means the *expected value* (average) of $Y$ given $X=4$.\n\nThis ideal $f(x) = E(Y|X=x)$ is called the **regression function**.\n\n:::\n\n:::\n:::\n\n## The Regression Function $f(x)$\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n\n- **Is also defined for a vector $\\mathbf{X}$**. \n\n$$\nf(\\mathbf{x}) = f(x_1, x_2, x_3) = \\mathbb{E}[\\,Y \\mid X_1 = x_1,\\, X_2 = x_2,\\, X_3 = x_3\\,].\n$$\n\n:::{.fragment}\n\n- **Is the ideal or optimal predictor** of $Y$ in terms of mean-squared prediction error:\n\n$$\n  f(x) = \\mathbb{E}[Y \\mid X = x]\n  \\quad\\text{is the function that minimizes}\\quad \n  \\mathbb{E}[(Y - g(X))^2 \\mid X = x]\n  \\text{ over all } g \\text{ and for all points } X = x.\n$$\n:::\n\n:::{.fragment}\n\n- $\\varepsilon = Y - f(x)$ is the **irreducible error**.\n\n    - Even if we knew $f(x)$, we would still make prediction errors because at each $X = x$ there is a distribution of possible $Y$ values.\n\n:::\n\n:::{.fragment}\n\n- For any estimate $\\hat{f}(x)$ of $f(x)$, \n\n$$\n    \\mathbb{E}\\bigl[(Y - \\hat{f}(X))^2 \\mid X = x\\bigr] \n    = \\underbrace{[\\,f(x) - \\hat{f}(x)\\,]^2}_{\\text{Reducible}} \n      \\;+\\; \\underbrace{\\mathrm{Var}(\\varepsilon)}_{\\text{Irreducible}}.\n$$\n\n:::\n\n:::\n:::\n\n\n## How to Estimate $f$\n\n:::{.nonincremental}\n\n- Often, we lack sufficient data points for exact computation of $E(Y|X=x)$.  \n\n- So, we relax the definition:\n\n$$\n\\hat{f}(x) = \\text{Ave}(Y|X \\in \\mathcal{N}(x))\n$$\n\nwhere $\\mathcal{N}(x)$ is a *neighborhood* of $x$.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_3.png){fig-align='center' width=50%}\n:::\n:::\n\n\n<br>\n\n:::\n\n\n## Nearest Neighbor Observations\n\n- **Nearest neighbor averaging** can be pretty good for small $p$  — i.e., $p \\le 4$ — and large-ish $N$.\n\n- We will discuss **smoother versions**, such as kernel and spline smoothing, later in the course.\n\n- Nearest neighbor methods can be **lousy** when $p$ is large. \n  \n    - Reason: the *curse of dimensionality*. Nearest neighbors tend to be far away in high dimensions.\n\n    - We need to get a **reasonable fraction** of the $N$ values of $y_i$ to average in order to bring the variance down (e.g., 10%).\n  \n    - A 10% neighborhood in high dimensions is **no longer truly local**, so we lose the spirit of estimating $\\mathbb{E}[Y \\mid X = x]$ via local averaging.\n\n## The curse of dimensionality\n\n::: nonincremental\n::: {style=\"font-size: 65%;\"}\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_4_1.png){fig-align='center' width=40%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_4_2.png){fig-align='center' width=40%}\n:::\n:::\n\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n**Top panel:** $X_1$ and $X_2$ are uniformly distributed with edges minus one to plus one.\n\n- **1-Dimensional Neighborhood**\n\n    - Focuses only on $X_1$, ignoring $X_2$.\n    - Neighborhood is defined by vertical red dotted lines.\n    - Centered on the target point $(0, 0)$.\n    - Extends symmetrically along $X_1$ until it captures 10% of the data points.\n\n- **2-Dimensional Neighborhood**\n\n    - Now, Considers both $X_1$ and $X_2$.\n    - Neighborhood is a circular region centered on the same target point $(0, 0)$.\n    - Radius of the circle expands until it encloses 10% of the total data points.\n    - The radius in 2D is much larger than the 1D width due to the need to account for more dimensions.\n\n:::{.fragment}\n\n**Botton panel**: We see how far we have to go out in one, two, three, five, and ten dimensions in order to capture a certain fraction of the points.\n\n<br>\n\n**Key Takeaway**: As dimensionality increases, neighborhoods must expand significantly to capture the same fraction of data points, illustrating the **curse of dimensionality**.\n\n:::\n\n:::\n::::\n\n\n:::\n:::\n\n<br>\n\n# Parametric and Structured Models {background-color=\"#cfb991\"}\n\n## Parametric and Structured Models\n\nThe **linear model** is a key example of a parametric model to deal with the *curse of dimensionality*:\n\n$$\nf_L(X) = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\ldots + \\beta_pX_p\n$$\n\n- A linear model is specified in terms of $p+1$ parameters ($\\beta_0, \\beta_1, \\ldots, \\beta_p$).\n\n- We estimate the parameters by fitting the model to training data.\n\n- Although it is *almost never correct*, it serves as a good and interpretable approximation to the unknown true function $f(X)$.\n\n## Comparison of Models\n\n:::::: nonincremental\n::::: columns\n::: {.column width=\"50%\" style=\"text-align: center; justify-content: center; align-items: center;\"}\n\n<center>\n**Linear model**\n</center>\n\n$$\n\\hat{f}_L(X) = \\hat{\\beta}_0 + \\hat{\\beta}_1X\n$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_5.png){fig-align='center' width=90%}\n:::\n:::\n\n\nThe linear model gives a reasonable fit here.\n\n:::\n\n::: {.column width=\"50%\" style=\"text-align: center; justify-content: center; align-items: center;\"}\n\n:::{.fragment}\n\n<center>\n**Quadratic model:**\n</center>\n\n$$\n\\hat{f}_Q(X) = \\hat{\\beta}_0 + \\hat{\\beta}_1X + \\hat{\\beta}_2X^2\n$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_6.png){fig-align='center' width=90%}\n:::\n:::\n\n\nQuadratic models may fit slightly better than linear models in some cases.\n\n:::\n:::\n:::::\n::::::\n\n\n## Simulated Example\n\nRed points are simulated values for **income** from the model:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_3-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n$$\n\\text{income} = f(\\text{education}, \\text{seniority}) + \\epsilon\n$$\n\n$f$ is the blue surface.\n\n<br>\n\n\n## Linear Regression Fit\n\nLinear regression model fit to the simulated data:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_4-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n$$\n\\hat{f}_L(\\text{education}, \\text{seniority}) = \\hat{\\beta}_0 + \\hat{\\beta}_1 \\times \\text{education} + \\hat{\\beta}_2 \\times \\text{seniority}\n$$\n\n<br>\n\n## Flexible Regression Model Fit\n\nMore flexible regression model $\\hat{f}_S(\\text{education}, \\text{seniority})$ fit to the simulated data. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_5-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nHere we use a technique called a *thin-plate spline* to fit a flexible surface. We control the roughness of the fit.\n\n<br>\n\n## Overfitting\n\nEven more flexible spline regression model $\\hat{f}_S(\\text{education}, \\text{seniority})$ fit to the simulated data. We tunned the parameter all the way down to zero and this surface actually goes through every single data point.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_6-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nThe fitted model makes no errors on the training data! This is known as **overfitting**.\n\n<br>\n\n## Some Trade-offs\n\n- **Prediction accuracy versus interpretability**:  \n\n    - Linear models are easy to interpret; thin-plate splines are not.\n\n- **Good fit versus over-fit or under-fit**:  \n\n    - How do we know when the fit is just right?\n\n- **Parsimony versus black-box**:  \n\n    - Prefer simpler models involving fewer variables over black-box predictors.\n\n\n## Flexibility vs. Interpretability\n\n::: {style=\"font-size: 80%;\"}\n\nTrade-offs between **flexibility** and **interpretability**:  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_7-1.png){fig-align='center' width=50%}\n:::\n:::\n\n\n- **High interpretability**: Subset selection, Lasso.  \n- **Intermediate**: Least squares, Generalized Additive Models, Trees.  \n- **High flexibility**: Support Vector Machines, Deep Learning.  \n\n\n<br>\n\n:::\n\n# Assessing Model Accuracy {background-color=\"#cfb991\"}\n\n## Assessing Model Accuracy\n\n::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\nSuppose we fit a model $\\hat{f}(x)$ to some training data $Tr = \\{x_i, y_i\\}_{i=1}^N$, and we wish to evaluate its performance:\n\n- Compute the average squared prediction error over the training set $Tr$, the Mean Squared Error (MSE):\n\n$$\n\\text{MSE}_{Tr} = \\text{Ave}_{i \\in Tr}[(y_i - \\hat{f}(x_i))^2]\n$$\n\nHowever, this may be biased toward more overfit models.\n\n:::{.fragment}\n\n- Instead, use fresh **test data** $Te = \\{x_i, y_i\\}_{i=1}^M$:\n\n$$\n\\text{MSE}_{Te} = \\text{Ave}_{i \\in Te}[(y_i - \\hat{f}(x_i))^2]\n$$\n\n:::\n:::\n:::\n\n\n## Bias-Variance Trade-off\n\n::: nonincremental\n::: {style=\"font-size: 55%;\"}\n\n\n:::: {.columns}\n::: {.column width=\"45%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_9-1-1.png){fig-align='center' width=45%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_9-1-2.png){fig-align='center' width=45%}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"55%\"}\n\n**Top Panel: Model Fits**\n\n- **Black Curve**: The true generating function, representing the underlying relationship we want to estimate.\n\n- **Data Points**: Observations generated from the black curve, with added noise (error).\n\n- **Fitted Models**:\n\n    - **Orange Line**: A simple linear model (low flexibility).\n    - **Blue Line**: A moderately flexible model, likely a spline or thin plate spline.\n    - **Green Line**: A highly flexible model that closely fits the data points but may overfit.\n\n**Key Insight**:  \n\nThe green model captures the data points well but risks overfitting, while the orange model is too rigid and misses the underlying structure. The blue model strikes a balance.\n\n:::{.fragment}\n\n**Botton Panel: Mean Squared Error (MSE)**\n\n- **Gray Curve**: Training data MSE.\n\n    - Decreases consistently as flexibility increases.\n    - Flexible models fit the training data well, but this does not generalize to test data.\n\n- **Red Curve**: Test data MSE across models of increasing flexibility.\n  \n    - Starts high for rigid models (orange line).\n    - Decreases to a minimum (optimal model complexity, blue line).\n    - Increases again for overly flexible models (green line), due to overfitting.\n\n**Key Takeaway**:  \nThere is an optimal model complexity (the \"magic point\") where test data MSE is minimized. Beyond this point, models become overly complex and generalization performance deteriorates.\n\n:::\n\n:::\n::::\n\n:::\n:::\n\n\n## Bias-Variance Trade-off: Other Examples\n\n::: nonincremental\n::: {style=\"font-size: 65%;\"}\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n<br>\n\nHere, the truth is **smoother**, so smoother fits and linear models perform well.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_10-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n\n:::\n::: {.column width=\"50%\"}\n\n:::{.fragment}\n\n<br>\n\nHere, the truth is **wiggly** and the noise is low. More flexible fits perform the best.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_11-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n:::\n\n\n:::\n::::\n\n\n:::\n:::\n\n\n## Bias-Variance Trade-off\n\n:::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\nSuppose we have fit a model $\\hat{f}(x)$ to some training data $\\text{Tr}$, \nand let $(x_0, y_0)$ be a test observation drawn from the population. \n\nIf the true model is \n\n$$\n    Y = f(X) + \\varepsilon \n    \\quad \\text{(with } f(x) = \\mathbb{E}[Y \\mid X = x]\\text{)},\n$$\n\nthen\n\n$$\n\\mathbb{E}\\Bigl[\\bigl(y_0 - \\hat{f}(x_0)\\bigr)^2\\Bigr] \n    = \\mathrm{Var}\\bigl(\\hat{f}(x_0)\\bigr) \n    + \\bigl[\\mathrm{Bias}\\bigl(\\hat{f}(x_0)\\bigr)\\bigr]^2 \n    + \\mathrm{Var}(\\varepsilon).\n$$\n\nThe expectation averages over the variability of $y_0$ as well as the \nvariability in $\\text{Tr}$. Note that\n\n$$\n    \\mathrm{Bias}\\bigl(\\hat{f}(x_0)\\bigr) \n    = \\mathbb{E}[\\hat{f}(x_0)] - f(x_0).\n$$\n\nTypically, as the **flexibility** of $\\hat{f}$ increases, its variance increases and its bias decreases. Hence, choosing the flexibility based on average test error amounts to a **bias-variance trade-off**.\n\n<br>\n\n::::\n:::\n\n## Bias-Variance Trade-off of the Examples\n\n:::: nonincremental\n::: {style=\"font-size: 70%;\"}\n\nBelow is a schematic illustration of the mean squared error (MSE), bias, \nand variance curves as a function of the model’s flexibility.\n\n::: {.column-screen}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_12-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n- **MSE (red curve)** goes down initially (as the model becomes more flexible) \n  but eventually goes up (as overfitting sets in).\n  \n- **Bias (blue/teal curve)** decreases with increasing flexibility.\n\n- **Variance (orange curve)** increases with increasing flexibility.\n\n:::\n\nThe vertical dotted line in each panel suggests a model flexibility that balances \nboth bias and variance in an “optimal” region for minimizing MSE.\n\n::::\n:::\n\n<br>\n\n# Classification Problems {background-color=\"#cfb991\"}\n\n## Classification Problems\n\n:::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\nHere the response variable $Y$ is **qualitative**. For example:\n\n- Email could be classified as **spam** or **ham** (good email).\n    \n- Digit classification could be one of $\\{0, 1, 2, \\dots, 9\\}$.\n\n:::{.fragment}\n\nOur goals are to:\n\n1. Build a classifier $C(X)$ that assigns a class label from the set $C$ to a future unlabeled observation $X$.\n    \n2. Assess the uncertainty in each classification.\n    \n3. Understand the roles of the different predictors among $X = (X_1, X_2, \\dots, X_p)$.\n\n:::\n\n::::\n::: \n\n## Ideal Classifier and Bayes Decision Rule\n\n:::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_7.png){fig-align='center' width=50%}\n:::\n:::\n\n\nConsider a classification problem with $K$ possible classes,  numbered $1, 2, \\ldots, K$. Define\n\n$$\n  p_k(x) = \\Pr(Y = k \\mid X = x), \n  \\quad k = 1, 2, \\ldots, K.\n$$\n\nThese are the **conditional class probabilities** at $x$; e.g. see little\nbarplot at $x=5$. \n\nThe **Bayes optimal** classifier at $x$ is\n\n$$\n  C(x) \\;=\\; j \\quad \\text{if} \\quad p_j(x) = \n      \\max \\{\\,p_1(x),\\, p_2(x),\\, \\dots,\\, p_K(x)\\}.\n$$\n\n::::\n:::\n\n<br>\n\n## Nearest-Neighbor Averaging\n\n:::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_8.png){fig-align='center' width=60%}\n:::\n:::\n\n\nNearest-neighbor averaging can be used as before.  \n\nAlso breaks down as dimension grows. However, the impact on $\\hat{C}(x)$is less than on $\\hat{p}_k(x)$, for $k = 1,\\ldots,K$.\n\n::::\n:::\n\n\n## Classification: Some Details\n\n:::: nonincremental\n::: {style=\"font-size: 90%;\"}\n\nTypically we measure the performance of $\\hat{C}(x)$ using the **misclassification error rate**:\n\n$$\n    \\mathrm{Err}_{\\mathrm{Te}} \n      = \\mathrm{Ave}_{i\\in \\mathrm{Te}} \n        \\bigl[I(y_i \\neq \\hat{C}(x_i))\\bigr].\n$$\n\n- The **Bayes classifier** (using the true $p_k(x)$) has the smallest error in the population.\n\n- **Support-vector machines** build structured models for $\\hat{C}(x)$.\n\n- We also build **structured models** for representing $p_k(x)$. For example, logistic regression or generalized additive models.\n\n::::\n:::\n\n\n## Example: K-Nearest Neighbors in Two Dimensions\n\nBelow is an example data set in two dimensions $(X_1, X_2)$. Points shown in **blue** might represent one class, and points in **orange** the other. The dashed boundary suggests a decision boundary formed by a classifier.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_1_9.png){fig-align='center' width=80%}\n:::\n:::\n\n\n<br>\n\n## KNN: K = 10\n\nHere is the same data set classified by **k-nearest neighbors** with $k = 10$. \nThe black boundary line encloses the region of the feature space predicted as orange vs. blue, showing how the decision boundary has become smoother.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_15-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n<br>\n\n## KNN: K = 1 vs. K = 100\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_16-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nComparisons of a **very low** value of $k$ (left, $k=1$) versus a **very high** value (right, $k=100$). \n\n- **$k=1$**: Overly flexible boundary that can overfit.\n\n- **$k=100$**: Very smooth boundary that can underfit.\n\n<br>\n\n## KNN Error Rates\n\n:::: nonincremental\n::: {style=\"font-size: 80%;\"}\n\n:::: {.columns}\n::: {.column width=\"45%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/2_17-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n::: \n\n::: {.column width=\"45%\"}\n\nThe figure illustrates how **training errors** (blue curve) and **test errors** (orange curve) change for a K-nearest neighbors (KNN) classifier as $\\frac{1}{K}$ varies.  \n\n- **For small $K$** (i.e., large $\\frac{1}{K}$), the model can become very flexible, often driving down training error but increasing overfitting and thus test error.\n\n- **For large $K$** (i.e., small $\\frac{1}{K}$), the model becomes smoother, which can help avoid overfitting but sometimes leads to underfitting.\n\nThe dashed horizontal line is the bayes error, used as reference for comparison.\n\n\n:::\n\n::::\n\n::::\n:::\n\n<br>\n\n\n# Summary {background-color=\"#cfb991\"}\n\n## Summary\n\n:::: nonincremental\n::: {style=\"font-size: 70%;\"}\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n**Statistical Learning and Predictive Analytics**\n\n- **Goal**: Build models to predict outcomes and understand relationships between inputs (predictors) and responses.\n\n- **Supervised Learning**: Focuses on predicting $Y$ (response) using $X$ (predictors) via models like regression and classification.\n\n- **Unsupervised Learning**: Focuses on finding patterns in data without predefined responses (e.g., clustering).\n\n**Bias-Variance Trade-off**\n\n- **Key Trade-off**: Model flexibility affects bias and variance:\n\n    - **High flexibility** → Low bias but high variance (overfitting).\n     - **Low flexibility** → High bias but low variance (underfitting).\n\n- Goal: Find the optimal flexibility that minimizes test error.\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Techniques and Applications**\n\n- **Parametric Models**:\n\n    - Simpler and interpretable (e.g., linear regression).\n    - Often used as approximations.\n\n- **Flexible Models**:\n\n    - Handle complex patterns (e.g., splines, SVMs, deep learning).\n    - Require careful tuning to avoid overfitting.\n\n**Practical Considerations**\n\n- **Assessing Model Accuracy**:\n\n    - Use test data to calculate MSE.\n    - Balance between training performance and generalizability.\n\n**Key Challenges**\n\n- **Curse of Dimensionality**:\n\n    - High-dimensional data affects distance-based methods like KNN.\n    - Larger neighborhoods needed, losing \"locality.\"\n\n:::\n::::\n\n::::\n::: \n\n\n# Thank you! {background-color=\"#cfb991\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}